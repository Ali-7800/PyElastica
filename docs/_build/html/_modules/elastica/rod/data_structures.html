

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>elastica.rod.data_structures &mdash; Elastica 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Elastica
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Elastica:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../welcome_page.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Pyelastica</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../elastica++.html">Elastica++</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Elastica</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../rod.html">elastica.rod</a> &raquo;</li>
        
      <li>elastica.rod.data_structures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for elastica.rod.data_structures</h1><div class="highlight"><pre>
<span></span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Data structure wrapper for rod components&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">elastica._rotations</span> <span class="kn">import</span> <span class="n">_get_rotation_matrix</span><span class="p">,</span> <span class="n">_rotate</span>


<span class="c1"># FIXME : Explicit Stepper doesn&#39;t work as States lose the</span>
<span class="c1"># views they initially had when working with a timestepper.</span>
<div class="viewcode-block" id="_RodExplicitStepperMixin"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._RodExplicitStepperMixin">[docs]</a><span class="k">class</span> <span class="nc">_RodExplicitStepperMixin</span><span class="p">:</span>
<div class="viewcode-block" id="_RodExplicitStepperMixin.__init__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._RodExplicitStepperMixin.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__deriv_state</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceleration_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_collection</span><span class="p">,</span>  <span class="c1"># angular acceleration</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">_bootstrap_from_data</span><span class="p">(</span>
            <span class="s2">&quot;explicit&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vector_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_states</span>
        <span class="p">)</span></div>

    <span class="c1"># def __setattr__(self, name, value):</span>
    <span class="c1">#     np.copy(self.__dict__[name], value)</span>

<div class="viewcode-block" id="_RodExplicitStepperMixin.__call__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._RodExplicitStepperMixin.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_accelerations</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>  <span class="c1"># Internal, external</span>

        <span class="c1"># print(&quot;KRC&quot;, self.state.kinematic_rate_collection)</span>
        <span class="c1"># print(&quot;DEr&quot;, self.__deriv_state.rate_collection)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">kinematic_rate_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity_collection</span>
            <span class="c1"># self.__deriv_state.rate_collection</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shares memory&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Explicit states does not share memory&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__deriv_state</span></div></div>


<div class="viewcode-block" id="_RodSymplecticStepperMixin"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._RodSymplecticStepperMixin">[docs]</a><span class="k">class</span> <span class="nc">_RodSymplecticStepperMixin</span><span class="p">:</span>
<div class="viewcode-block" id="_RodSymplecticStepperMixin.__init__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._RodSymplecticStepperMixin.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_states</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_states</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceleration_collection</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha_collection</span><span class="p">,</span>  <span class="c1"># angular acceleration</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">_bootstrap_from_data</span><span class="p">(</span>
            <span class="s2">&quot;symplectic&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elems</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vector_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_states</span>
        <span class="p">)</span>
        <span class="c1"># Expose rate returning functions in the interface</span>
        <span class="c1"># to be used by the time-stepping algorithm</span>
        <span class="c1"># dynamic rates needs to call update_accelerations and henc</span>
        <span class="c1"># is another function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_states</span><span class="o">.</span><span class="n">kinematic_rates</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The following commented block of code is a test to ensure that</span>
<span class="sd">    the time-integrator always updates the view of the</span>
<span class="sd">    collection variables, and not an independent variable</span>
<span class="sd">    (aka no copy is made). It exists only for legacy</span>
<span class="sd">    purposes and will be either refactored or removed once</span>
<span class="sd">    testing is done.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># def kinematic_rates(self, time, *args, **kwargs):</span>
    <span class="c1">#     def shmem(a, b):</span>
    <span class="c1">#         if np.shares_memory(</span>
    <span class="c1">#                 a, b</span>
    <span class="c1">#         ) : print(&quot;Shares memory ools&quot;)</span>
    <span class="c1">#         else :</span>
    <span class="c1">#             print(&quot;Explicit states does not share memory&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#     shmem(self.kinematic_states.position_collection, self.position_collection)</span>
    <span class="c1">#     shmem(self.kinematic_states.director_collection, self.director_collection)</span>
    <span class="c1">#</span>
    <span class="c1">#     return self.dynamic_states.kinematic_rates(time, *args, **kwargs)</span>

    <span class="c1"># TODO: find better way and place to compute internal forces and torques</span>
<div class="viewcode-block" id="_RodSymplecticStepperMixin.update_internal_forces_and_torques"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._RodSymplecticStepperMixin.update_internal_forces_and_torques">[docs]</a>    <span class="k">def</span> <span class="nf">update_internal_forces_and_torques</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_internal_forces_and_torques</span><span class="p">(</span><span class="n">time</span><span class="p">)</span></div>

<div class="viewcode-block" id="_RodSymplecticStepperMixin.dynamic_rates"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._RodSymplecticStepperMixin.dynamic_rates">[docs]</a>    <span class="k">def</span> <span class="nf">dynamic_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_accelerations</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following commented block of code is a test to ensure that</span>
<span class="sd">        the time-integrator always updates the view of the</span>
<span class="sd">        collection variables, and not an independent variable</span>
<span class="sd">        (aka no copy is made). It exists only for legacy</span>
<span class="sd">        purposes and will be either refactored or removed once</span>
<span class="sd">        testing is done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># def shmem(x):</span>
        <span class="c1">#     if np.shares_memory(</span>
        <span class="c1">#             self.dynamic_states.rate_collection, x</span>
        <span class="c1">#     ) : print(&quot;Shares memory&quot;)</span>
        <span class="c1">#     else :</span>
        <span class="c1">#         print(&quot;Explicit states does not share memory&quot;)</span>
        <span class="c1"># shmem(self.velocity_collection)</span>
        <span class="c1"># shmem(self.acceleration_collection)</span>
        <span class="c1"># shmem(self.omega_collection)</span>
        <span class="c1"># shmem(self.alpha_collection)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_states</span><span class="o">.</span><span class="n">dynamic_rates</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="_bootstrap_from_data"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._bootstrap_from_data">[docs]</a><span class="k">def</span> <span class="nf">_bootstrap_from_data</span><span class="p">(</span><span class="n">stepper_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_elems</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">vector_states</span><span class="p">,</span> <span class="n">matrix_states</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns states wrapping numpy arrays based on the time-stepping algorithm</span>

<span class="sd">    Convenience method that takes in rod internal (raw np.ndarray) data, create views</span>
<span class="sd">    (references) from it, and outputs State classes that are used in the time-stepping</span>
<span class="sd">    algorithm. This means that modifying the state modifies the internal data!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stepper_type : str (likely to change in future), representing stepper type</span>
<span class="sd">    Allowed parameters are [&#39;explicit&#39;, &#39;symplectic&#39;]</span>
<span class="sd">    n_elems : int, number of rod elements</span>
<span class="sd">    vector_states : np.ndarray of shape (dim, *) with the following structure</span>
<span class="sd">        `vector_states` = [`position`,`velocity`,`omega`,`acceleration`,`angular acceleration`]</span>
<span class="sd">        `n_nodes = n_elems + 1`</span>
<span class="sd">        `position = 0 -&gt; n_nodes , size = n_nodes`</span>
<span class="sd">        `velocity = n_nodes -&gt; 2 * n_nodes, size = n_nodes`</span>
<span class="sd">        `omega = 2 * n_nodes -&gt; 2 * n_nodes + nelem, size = nelem`</span>
<span class="sd">        `acceleration = 2 * n_nodes + nelem -&gt; 3 * n_nodes + nelem, size = n_nodes`</span>
<span class="sd">        `angular acceleration = 3 * n_nodes + nelem -&gt; 3 * n_nodes + 2 * nelem, size = n_elems`</span>
<span class="sd">    matrix_states : np.ndarray of shape (dim, dim, n_elems) containing the directors</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : tuple of len 8 containing</span>
<span class="sd">    (state, derivative_state, position, directors, velocity, omega, acceleration, alpha)</span>
<span class="sd">    derivative_state carries rate information</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">n_elems</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vector_states</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">n_nodes</span><span class="p">])</span>
    <span class="n">directors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">matrix_states</span><span class="p">)</span>
    <span class="n">v_w_dvdt_dwdt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vector_states</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">:])</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">if</span> <span class="n">stepper_type</span> <span class="o">==</span> <span class="s2">&quot;explicit&quot;</span><span class="p">:</span>
        <span class="n">v_w_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vector_states</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n_nodes</span> <span class="p">:</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">_State</span><span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">directors</span><span class="p">,</span> <span class="n">v_w_states</span><span class="p">),</span>
            <span class="n">_DerivativeState</span><span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">v_w_dvdt_dwdt</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">stepper_type</span> <span class="o">==</span> <span class="s2">&quot;symplectic&quot;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">_KinematicState</span><span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">directors</span><span class="p">),</span>
            <span class="n">_DynamicState</span><span class="p">(</span><span class="n">n_elems</span><span class="p">,</span> <span class="n">v_w_dvdt_dwdt</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">n_velocity_end</span> <span class="o">=</span> <span class="n">n_nodes</span> <span class="o">+</span> <span class="n">n_nodes</span>
    <span class="n">velocity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vector_states</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">:</span><span class="n">n_velocity_end</span><span class="p">])</span>

    <span class="n">n_omega_end</span> <span class="o">=</span> <span class="n">n_velocity_end</span> <span class="o">+</span> <span class="n">n_elems</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vector_states</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n_velocity_end</span><span class="p">:</span><span class="n">n_omega_end</span><span class="p">])</span>

    <span class="n">n_acceleration_end</span> <span class="o">=</span> <span class="n">n_omega_end</span> <span class="o">+</span> <span class="n">n_nodes</span>
    <span class="n">acceleration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vector_states</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n_omega_end</span><span class="p">:</span><span class="n">n_acceleration_end</span><span class="p">])</span>

    <span class="n">n_alpha_end</span> <span class="o">=</span> <span class="n">n_acceleration_end</span> <span class="o">+</span> <span class="n">n_elems</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">vector_states</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n_acceleration_end</span><span class="p">:</span><span class="n">n_alpha_end</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">output</span> <span class="o">+</span> <span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">directors</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">acceleration</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Explicit stepper interface</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="_State"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._State">[docs]</a><span class="k">class</span> <span class="nc">_State</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; State for explicit steppers.</span>

<span class="sd">    Wraps data as state, with overloaded methods for explicit steppers</span>
<span class="sd">    (steppers that integrate all states in one-step/stage).</span>
<span class="sd">    Allows for separating implementation of stepper from actual</span>
<span class="sd">    addition/multiplication/other formulae used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO : args, kwargs instead of hardcoding types</span>
<div class="viewcode-block" id="_State.__init__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._State.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_elems</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">position_collection_view</span><span class="p">,</span>
        <span class="n">director_collection_view</span><span class="p">,</span>
        <span class="n">kinematic_rate_collection_view</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_elems : int, number of rod elements</span>
<span class="sd">        position_collection_view : view of positions (or) x</span>
<span class="sd">        director_collection_view : view of directors (or) Q</span>
<span class="sd">        kinematic_rate_collection_view : view of velocity and omega (or) (v,ω)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_State</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="o">=</span> <span class="n">n_elems</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="o">+</span> <span class="n">n_elems</span>  <span class="c1"># start of (v,ω) in (x,Q,v,ω)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_collection</span> <span class="o">=</span> <span class="n">position_collection_view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span> <span class="o">=</span> <span class="n">director_collection_view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_rate_collection</span> <span class="o">=</span> <span class="n">kinematic_rate_collection_view</span></div>

<div class="viewcode-block" id="_State.__iadd__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._State.__iadd__">[docs]</a>    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_deriv_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; overloaded += operator</span>

<span class="sd">        The add for directors is customized to reflect Rodrigues&#39; rotation</span>
<span class="sd">        formula.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaled_deriv_array : np.ndarray containing dt * (v, ω, dv/dt, dω/dt)</span>
<span class="sd">        ,as returned from _DerivativeState&#39;s __mul__ method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : _State with inplace modified data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x += v*dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_collection</span> <span class="o">+=</span> <span class="n">scaled_deriv_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">]</span>
        <span class="c1"># TODO : Verify the math in this note</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Developer Note</span>
<span class="sd">        --------------</span>
<span class="sd">        Here the overloaded `+=` operator is exploited to perform</span>
<span class="sd">        matrix multiplication for the directors, which is counter-</span>
<span class="sd">        intutive at first. While this provides a stable interface</span>
<span class="sd">        to interact the rod states with the timesteppers and the</span>
<span class="sd">        rest of the world, the reasons behind including it here also has</span>
<span class="sd">        a depper mathematical significance.</span>

<span class="sd">        Firstly, position lies in the vector space corresponding to R^{3}</span>
<span class="sd">        and update is done this space (with the + and * operators defined</span>
<span class="sd">        as usual), hence the `+=` operator (or `__iadd__`) is reflected</span>
<span class="sd">        as `+=` operator in the position update (line 163 above).</span>

<span class="sd">        For directors rather, which lie in a restricteed R^{3} \otimes</span>
<span class="sd">        R^{3} tensorial space, the space with Q^T.Q = Q.Q^T = I, the +</span>
<span class="sd">        operator can be thought of as an equivalent `*=` update for a</span>
<span class="sd">        &#39;exponential&#39; multiplication with a rotation matrix (e^{At}).</span>
<span class="sd">        . This does not correspond to the position update. However, if</span>
<span class="sd">        we view this in a logarithmic space the `*=` becomse the &#39;+=&#39;</span>
<span class="sd">        operator once again! After performing this `+=` operation, we</span>
<span class="sd">        bring it back into its original space using the exponential</span>
<span class="sd">        operator. So we are still indirectly doing the &#39;+=&#39;</span>
<span class="sd">        update.</span>

<span class="sd">        To avoid all this hassle with the operators and spaces, we simply define</span>
<span class="sd">        &#39;+=&#39; or &#39;__iadd__&#39; in the case of directors as an equivalent</span>
<span class="sd">        &#39;*=&#39; (matrix multiply) with the RHS below.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO Q *= exp(w*dt) , whats&#39; the formua again?</span>
        <span class="c1"># TODO the scale factor 1.0 does not seem to be necessary, although</span>
        <span class="c1"># we perform more work in the present framework (muliply dt to entire vector, then take</span>
        <span class="c1"># norm) rather than vector norm then multiple by dt (1/3 operation costs)</span>
        <span class="c1"># TODO optimize (somehow) extra copy away : if we don&#39;t make a copy</span>
        <span class="c1"># its even more slower, maybe due to aliasing effects</span>
        <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;ijk,jlk-&gt;ilk&quot;</span><span class="p">,</span>
            <span class="n">_get_rotation_matrix</span><span class="p">(</span>
                <span class="mf">1.0</span><span class="p">,</span> <span class="n">scaled_deriv_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># (v,ω) += (dv/dt, dω/dt)*dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_rate_collection</span> <span class="o">+=</span> <span class="n">scaled_deriv_array</span><span class="p">[</span>
            <span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span> <span class="p">:</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="_State.__add__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._State.__add__">[docs]</a>    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_derivative_state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; overloaded + operator, useful in state.k1 = state + dt * deriv_state</span>

<span class="sd">        The add for directors is customized to reflect Rodrigues&#39; rotation</span>
<span class="sd">        formula.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaled_derivative_state : np.ndarray with dt * (v, ω, dv/dt, dω/dt)</span>
<span class="sd">        ,as returned from _DerivativeState&#39;s __mul__ method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        state : new _State object with modified data (copied)</span>

<span class="sd">        Caveats</span>
<span class="sd">        -------</span>
<span class="sd">        Note that the argument is not a `other` _State object but is rather</span>
<span class="sd">        assumed to be a `np.ndarray` from calling _DerivativeState&#39;s __mul__</span>
<span class="sd">        method. This reflects the most common use-case in time-steppers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x += v*dt</span>
        <span class="n">position_collection</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position_collection</span> <span class="o">+</span> <span class="n">scaled_derivative_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Devs : see `_State.__iadd__` for reasons why we do matmul here</span>
        <span class="n">director_collection</span> <span class="o">=</span> <span class="n">_rotate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span><span class="p">,</span>
            <span class="mf">1.0</span><span class="p">,</span>
            <span class="n">scaled_derivative_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># (v,ω) += (dv/dt, dω/dt)*dt</span>
        <span class="n">kinematic_rate_collection</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_rate_collection</span>
            <span class="o">+</span> <span class="n">scaled_derivative_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span> <span class="p">:]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">_State</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">position_collection</span><span class="p">,</span>
            <span class="n">director_collection</span><span class="p">,</span>
            <span class="n">kinematic_rate_collection</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="_DerivativeState"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DerivativeState">[docs]</a><span class="k">class</span> <span class="nc">_DerivativeState</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; TimeDerivative of States for explicit steppers.</span>

<span class="sd">    Wraps time-derivative data as state, with overloaded methods for</span>
<span class="sd">    explicit steppers (steppers that integrate all states in one-step/stage).</span>
<span class="sd">    Allows for separating implementation of stepper from actual addition</span>
<span class="sd">    /multiplication used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="_DerivativeState.__init__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DerivativeState.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_unused_n_elems</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rate_collection_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        _unused_n_elems : int, number of elements (unused, kept for</span>
<span class="sd">        compatibility with `_bootstrap_from_data`)</span>
<span class="sd">        rate_collection_view : np.ndarray containing (v, ω, dv/dt, dω/dt)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_DerivativeState</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_collection</span> <span class="o">=</span> <span class="n">rate_collection_view</span></div>

<div class="viewcode-block" id="_DerivativeState.__rmul__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DerivativeState.__rmul__">[docs]</a>    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; overloaded scalar * self,</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalar : float, typically dt (the time-step)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : np.ndarray containing (v*dt, ω*dt, dv/dt*dt, dω/dt*dt)</span>

<span class="sd">        Caveats</span>
<span class="sd">        -------</span>
<span class="sd">        Returns a np.ndarray and not a State object (as one expects).</span>
<span class="sd">        Returning a State here with (v*dt, ω*dt, dv/dt*dt, dω/dt*dt) as members</span>
<span class="sd">        is possible but it&#39;s less efficient, especially because this is hot</span>
<span class="sd">        piece of code</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Developer Note</span>
<span class="sd">        --------------</span>

<span class="sd">        Q : Why do we need to overload operators here?</span>

<span class="sd">        The Derivative class naturally doesn&#39;t have a `mul` overloaded</span>
<span class="sd">        operator. That means if this method is not present,</span>
<span class="sd">        doing something like</span>
<span class="sd">        ```</span>
<span class="sd">        ds = _DerivativeState(...)</span>
<span class="sd">        new_state = 2 * ds</span>
<span class="sd">        ```</span>
<span class="sd">        will throw an error. Note that you can do something like</span>
<span class="sd">        ```</span>
<span class="sd">        ds = _DerivativeState(...)</span>
<span class="sd">        new_state = 2 * ds.rate_collection</span>
<span class="sd">        ```</span>
<span class="sd">        but this is hacky, as we are exposing the members outside,</span>
<span class="sd">        in the calling scope (defeats encapsulation and hiding).</span>
<span class="sd">        The point of having this class is that it works</span>
<span class="sd">        well with the time-stepper (where we only use `+` and `*`</span>
<span class="sd">        operations on the State/DerivativeState like above,</span>
<span class="sd">        i.e. `state = dt * derivative_state`  and not something like</span>
<span class="sd">        `state = dt * derivative_state.rate_collection`).</span>
<span class="sd">        It also provides an interface for anything outside</span>
<span class="sd">        the `Rod` system as a whole.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scalar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_collection</span></div>

<div class="viewcode-block" id="_DerivativeState.__mul__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DerivativeState.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; overloaded self * scalar</span>

<span class="sd">        TODO Check if this pattern (forwarding to __mul__) has</span>
<span class="sd">        any disdvantages apart from extra function call penalty</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalar : float, typically dt (the time-step)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : np.ndarray containing (v*dt, ω*dt, dv/dt*dt, dω/dt*dt)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__rmul__</span><span class="p">(</span><span class="n">scalar</span><span class="p">)</span></div></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Symplectic stepper interface</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="_KinematicState"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._KinematicState">[docs]</a><span class="k">class</span> <span class="nc">_KinematicState</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; State storing (x,Q) for symplectic steppers.</span>

<span class="sd">    Wraps data as state, with overloaded methods for symplectic steppers.</span>
<span class="sd">    Allows for separating implementation of stepper from actual</span>
<span class="sd">    addition/multiplication/other formulae used.</span>

<span class="sd">    Symplectic steppers rely only on in-place modifications to state and so</span>
<span class="sd">    only these methods are provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="_KinematicState.__init__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._KinematicState.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n_elems</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">position_collection_view</span><span class="p">,</span> <span class="n">director_collection_view</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_elems : int, number of rod elements</span>
<span class="sd">        position_collection_view : view of positions (or) x</span>
<span class="sd">        director_collection_view : view of directors (or) Q</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_KinematicState</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="o">=</span> <span class="n">n_elems</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_collection</span> <span class="o">=</span> <span class="n">position_collection_view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span> <span class="o">=</span> <span class="n">director_collection_view</span></div>

<div class="viewcode-block" id="_KinematicState.__iadd__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._KinematicState.__iadd__">[docs]</a>    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_deriv_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; overloaded += operator</span>

<span class="sd">        The add for directors is customized to reflect Rodrigues&#39; rotation</span>
<span class="sd">        formula.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaled_deriv_array : np.ndarray containing dt * (v, ω),</span>
<span class="sd">        as retured from _DynamicState&#39;s `kinematic_rates` method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : _KinematicState instance with inplace modified data</span>

<span class="sd">        Caveats</span>
<span class="sd">        -------</span>
<span class="sd">        Takes a np.ndarray and not a _KinematicState object (as one expects).</span>
<span class="sd">        This is done for efficiency reasons, see _DynamicState&#39;s `kinematic_rates`</span>
<span class="sd">        method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x += v*dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_collection</span> <span class="o">+=</span> <span class="n">scaled_deriv_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">]</span>
        <span class="c1"># TODO Avoid code repeat</span>
        <span class="c1"># Devs : see `_State.__iadd__` for reasons why we do matmul here</span>
        <span class="c1"># print(_get_rotation_matrix(1.0, scaled_deriv_array[..., self.n_nodes:]))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;ijk,jlk-&gt;ilk&quot;</span><span class="p">,</span>
            <span class="n">_get_rotation_matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">scaled_deriv_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span> <span class="p">:]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">director_collection</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<div class="viewcode-block" id="_DynamicState"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DynamicState">[docs]</a><span class="k">class</span> <span class="nc">_DynamicState</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; State storing (v,ω, dv/dt, dω/dt) for symplectic steppers.</span>

<span class="sd">    Wraps data as state, with overloaded methods for symplectic steppers.</span>
<span class="sd">    Allows for separating implementation of stepper from actual</span>
<span class="sd">    addition/multiplication/other formulae used.</span>

<span class="sd">    Symplectic steppers rely only on in-place modifications to state and so</span>
<span class="sd">    only these methods are provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="_DynamicState.__init__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DynamicState.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_elems</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">rate_collection_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_elems : int, number of rod elements</span>
<span class="sd">        rate_collection_view : np.ndarray containing (v, ω, dv/dt, dω/dt)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_DynamicState</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Limit at which (v, w) end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_elems</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_collection</span> <span class="o">=</span> <span class="n">rate_collection_view</span></div>

<div class="viewcode-block" id="_DynamicState.__iadd__"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DynamicState.__iadd__">[docs]</a>    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_second_deriv_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; overloaded += operator, updating dynamic_rates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaled_second_deriv_array : np.ndarray containing dt * (dvdt, dωdt),</span>
<span class="sd">        as retured from _DynamicState&#39;s `dynamic_rates` method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : _DynamicState instance with inplace modified data</span>

<span class="sd">        Caveats</span>
<span class="sd">        -------</span>
<span class="sd">        Takes a np.ndarray and not a _DynamicState object (as one expects).</span>
<span class="sd">        This is done for efficiency reasons, see `dynamic_rates`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Always goes in LHS : that means the update is on the rates alone</span>
        <span class="c1"># (v,ω) += dt * (dv/dt, dω/dt) -&gt;  self.dynamic_rates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate_collection</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span><span class="p">]</span> <span class="o">+=</span> <span class="n">scaled_second_deriv_array</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="_DynamicState.kinematic_rates"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DynamicState.kinematic_rates">[docs]</a>    <span class="k">def</span> <span class="nf">kinematic_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Yields kinematic rates to interact with _KinematicState</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        v_and_omega : np.ndarray consisting of (v,ω)</span>

<span class="sd">        Caveats</span>
<span class="sd">        -------</span>
<span class="sd">        Doesn&#39;t return a _KinematicState with (dt*v, dt*w) as members,</span>
<span class="sd">        as one expects the _Kinematic __add__ operator to interact</span>
<span class="sd">        with another _KinematicState. This is done for efficiency purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># RHS functino call, gives v,w so that</span>
        <span class="c1"># Comes from kin_state -&gt; (x,Q) += dt * (v,w) &lt;- First part of dyn_state</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_collection</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span><span class="p">]</span></div>

<div class="viewcode-block" id="_DynamicState.dynamic_rates"><a class="viewcode-back" href="../../../documentation.html#elastica.rod.cosserat_rod._DynamicState.dynamic_rates">[docs]</a>    <span class="k">def</span> <span class="nf">dynamic_rates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Yields dynamic rates to add to with _DynamicState</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        acc_and_alpha : np.ndarray consisting of (dv/dt,dω/dt)</span>

<span class="sd">        Caveats</span>
<span class="sd">        -------</span>
<span class="sd">        Doesn&#39;t return a _DynamicState with (dt*v, dt*w) as members,</span>
<span class="sd">        as one expects the _Dynamic __add__ operator to interact</span>
<span class="sd">        with another _DynamicState. This is done for efficiency purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_collection</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_kinematic_rates</span> <span class="p">:]</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, mattiaLab

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>